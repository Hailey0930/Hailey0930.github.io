---
layout: post
title: "[기초부터 완성까지, 프런트엔드] 4장. 자바스크립트 기초"
summary: "4장. 자바스크립트 기초 (타입 변환과 함수)"
author: hyerin
date: "2023-02-22 22:38:00 +0900"
category: FrontendBook
thumbnail: /assets/img/posts/230217_2_thumbnail.jpg
keywords: Frontend
permalink:
usemathjax: true
---

# 타입 변환

자바스크립트의 타입 변환은 `명시적 강제 변환`, `암시적 강제 변환` 두 가지가 있다. `명시적 강제 변환`은 의도적인 타입 변환을 나타내는 것이고, `암시적 강제 변환`은 표현식의 평가 중 타입이 변환되는 것이다.

## 명시적 강제 변환

명시적 강제 변환은 명확하게 의도를 갖고 타입을 변환하는 것이다.

### 문자열로 변환

문자열로 변환하는 가장 간단한 방법은 `String()` 함수를 호출하는 것이다. new 키워드를 붙이지 않고 `String()` 함수를 호출하면 랩퍼 객체를 생성하는 것이 아니라 타입 변환 함수로 동작한다.

```javascript
console.log(String(3)); // '3'
console.log(String(false)); // 'false'
console.log(String(null)); // 'null'
```

다른 타입에서 문자열 타입으로의 변환은 타입별로 방법이 정해져있다. ECMAScript에서는 이 규칙을 `ToString 추상 연산`이라고 명시하고 있으며, 명시적이든 암시적이든 문자열로 변환될 때 수행된다.

> 정확히 말하면 `String()` 함수는 심볼 이외의 타입에 대해서 ToString 추상 연산을 따른다. 심볼 타입의 경우 `SymbolDescriptiveString` 연산을 통해 변환된다.

- `undefined` => `'undefined'`
- `null` => `'null'`
- `boolean` => `true` -> `'true'`, `false` -> `'false'`
- `number` => `Number.toString()`의 결과 반환 (3 -> '3')
- `Symbol` => 문자열로 변환을 시도하는 경우 TypeError 발생
- `BigInt` => `BigInt.toString()의 결과 반환 (3n -> '3n')
- `object` => 객체를 원시 타입으로 변환한 후 다시 한 번 ToString 추상 연산을 수행한 값을 반환한다. 객체를 원시 타입으로 변환하는 과정을 정확히는 `ToPrimitive 추상 연산`이라고 한다.

```javascript
const boolVal = true;
const numVal = 2;

console.log(String(boolVal)); // 'true'
console.log(String(numVal)); // '2'
```

> 심볼은 연산을 통해 문자열 또는 숫자로 변환될 경우 TypeError가 발생한다. 이는 심볼이 변환되어 객체의 다른 프로퍼티에 접근하는 것을 방지하기 위해서이다.

```javascript
myObject["__" + Symbol("key")]; // TypeError
```

또 다른 문자열 변환 방법은 `toString()` 메서드를 사용하는 것이다.

> 자바스크립트의 모든 객체는 `toString()` 메서드를 갖고 있다. 문자열, 숫자, 불리언 원시 타입은 랩퍼 객체를 통해 사용이 가능하며, 심볼과 BigInt는 자체적으로 구현된 `toString()` 메서드를 가지고 있다.

```javascript
const num = 4;
console.log(num.toString()); // '4'
```

#### `String()`과 `toString()`의 차이점

```javascript
console.log(String(null)); // 'null'
console.log(String(undefined)); // 'undefined'

undefined.toString(); // TypeError 발생
null.toString(); // TypeError 발생
```

null과 undefined 타입은 값이 비어 있음, 할당되지 않은 상태를 나타내는 원시 타입이므로 `toString()` 메서드를 호출할 수 있다면 논리상 말이 되지 않는다. 또한 이 타입들은 객체가 아니기 때문에 객체에서 사용할 수 있는 프로퍼티들을 사용할 수 없는 것이 옳다.<br />
반면, `String()` 함수의 경우 심볼 이외의 모든 타입이 규칙을 정확히 따르기 때문에 문자열로 명시적 강제 변환을 하고 싶은 경우엔 `toString()` 메서드보단 `String()` 함수를 사용하는 것이 더 적합하다.

### 숫자로 변환

숫자로의 변환도 문자열과 유사하게 `Number()` 함수를 호출하여 변환하는 방법이 있으며, BigInt 타입을 제외한 데이터는 ECMAScript의 `ToNumber` 추상 연산 명세를 기준으로 변환된다.

- undefined => NaN
- null => +0
- string => 숫자로 변경이 불가능한 값 -> NaN, 숫자형 문자열 -> 숫자
- boolean => true -> 1, false -> 0
- Symbol => 숫자로 변환을 시도하는 경우 TypeError 발생
- BigInt => 숫자로 변환을 시도하는 경우 TypeError 발생
- object => 객체를 원시 타입으로 변환한 후 다시 한 번 ToNumber 추상 연산을 수행한 값을 반환한다.

```javascript
console.log(Number("3")); // 3
console.log(Number(true)); // 1
console.log(Number(null)); // 0
```

> BigInt 타입은 연산 중 숫자로 변환되는 것을 방지하기 위해 TypeError를 발생시킨다. BigInt 타입은 숫자 타입과 다르게 큰 정수(안전한 숫자 타입의 범위를 벗어나는 정수)의 연산을 위해 나온 타입이기 때문에 숫자와는 타입이 구분되어야 한다.

#### `parseInt()` 함수

`parseInt()` 함수는 문자열만 대상으로 변환한다. 값이 문자열이 아닌 경우 해당 값을 문자열로 변환한 후 사용한다. 문자열의 변환 과정은 ToString 추상 연산 과정을 따른다.

```javascript
console.log(parseInt("10", 10)); // 10
console.log(parseInt("-1", 10)); // -1
```

`parseInt()` 함수의 두 번째 인자는 기수를 의미한다. 예제 코드는 기수를 10으로 지정하였기 때문에 10진수를 기준으로 문자열을 숫자로 변환한다. 기수를 생략하면 첫 번째 인자를 기준으로 추정하여 변환하므로 의도하지 않은 결과가 나올 수 있다.<br />
`parseInt()` 함수는 `Number()` 함수와 달리 인내심을 가지고 끝까지 변환을 수행한다.

```javascript
console.log(Number("10A", 10)); // NaN
console.log(parseInt("10A", 10)); // 10
```

`Number()` 함수의 경우 숫자로 변경 불가능한 문자가 있으면 곹바로 NaN을 반환하지만, `parseInt()` 함수는 변경 불가능한 문자가 나타날 때까지 최대한 숫자로 변환해서 결과를 반환한다.

### 불리언으로 변환

Boolean도 ECMAScript의 ToBoolean 추상 연산에 따라 타입을 변환한다.

- undefined => false
- null => false
- string => 빈 문자열 -> false, 그 외 문자열 -> true
- number => +0, -0, NaN -> false, 그 외 숫자 -> true
- Symbol => true
- BigInt => 0n -> false, 그 외 BigInt 정수 -> true
- object => true

불리언 타입으로의 변환은 `Boolean()` 함수를 호출하는 방법과 이중 부정 연산자를 사용하는 방법이 있으며, 두 연산은 모두 동일한 결과를 반환한다.

```javascript
const a = null;
const b = 0;
const c = "";
const d = {};
const e = [];

console.log(Boolean(a)); // false
console.log(Boolean(b)); // false
console.log(Boolean(c)); // false

console.log(Boolean(d)); // true
console.log(Boolean(e)); // true

console.log(!!a); // false
console.log(!!b); // false
console.log(!!c); // false

console.log(!!d); // true
console.log(!!e); // true
```

## 객체의 원시 타입 변환

객체의 원시 타입 변환은 문자열로 변환, 숫자로 변환 두 가지로 나눌 수 있다. 이 과정에서 `valeOf()`과 `toString()` 메서드가 중요한 역할을 한다.

### 문자열로 변환

1. 객체에 정의된 `toString()` 메서드를 호출한다. 별도로 정의한 `toString()` 메서드가 없다면 기본적으로 `Object`, `prototype.toString()` 메서드는 결과 값으로 `'[Object object]'` 문자열을 반환한다.
2. 1단계의 결과가 원시 타입이라면 그 결과를 문자열로 변환하여 반환하고, 그렇지 않다면 `valueOf()` 메서드를 호출한다. `valueOf()` 메서드 역시 객체에 별도로 정의한 `valueOf()` 메서드가 없다면 기본적으로 `Object.prototype.valueOf()` 메서드를 실행한다.
3. `valueOf()` 메서드의 결과 값이 원시 타입이라면 그 결과를 문자열로 변환하여 반환하고, 그렇지 않다면 TypeError가 발생한다.

```javascript
console.log(String({})); // '[Object object]'
```

빈 객체가 `'[Object object]'` 문자열로 변환되었다. `'[Object object]'`가 어떻게 나온 결과 값인지 의아할 수 있지만, 이 결과는 위의 단계를 정확하게 따른 결과이다.

1. 빈 객체를 문자열로 변환하기 위해 객체의 `toString()` 메서드를 호출한다. 직접 정의한 `toString()` 메서드가 없기 때문에 `Object.prototype.toString()` 메서드를 실행한다.
2. 1단계의 결과값은 `'[Object object]'` 문자열이며 원시 타입이기 때문에 이 결과를 반환한다.

빈 객체의 `toString()` 메서드의 결과값이 `'[Object object]'` 문자열 원시 타입이기 때문에 이 결과를 반환하는 것이다. 또한 `toString()` 메서드의 결과값이 원시 타입이기 때문에 `valueOf()` 메서드는 호출되지 않는다.

### 숫자로 변환

1. 객체에 정의된 `valueOf()` 메서드를 호출한다. 별도로 정의한 `valueOf()` 메서드가 없다면 기본적으로 `Object.prototype.valueOf()` 메서드를 실행한다. `Object.prototype.valueOf()` 메서드는 결과 값으로 객체를 그대로 반환한다.
2. 1단계의 결과가 원시 타입이라면 그 결과를 숫자로 변환하여 반환하고, 그렇지 않다면 `toString` 메서드를 호출한다. 별도로 정의한 `toString()` 메서드가 없다면 기본적으로 `Object.prototype.toString()` 메서드를 실행한다.
3. `toString()` 메서드의 결과 값이 원시 타입이라면 그 결과를 숫자로 변환하여 반환하고, 그렇지 않다면 TypeError가 발생한다.

`valueOf()` 메서드를 먼저 호출한 후 `toString()` 메서드를 호출하는 것을 제외하면 객체를 문자열로 변환하는 과과 유사하다.

```javascript
console.log(Number({})); // NaN
```

1. 빈 객체를 숫자로 변환하기 위해 객체의 `valueOf()` 메서드를 호출한다. 직접 정의한 `valueOf()` 메서드가 없기 때문에 `Object.prototype.valueOf()` 메서드를 실행한다.
2. 1단계의 결과값은 원시 타입이 아닌 빈 객체를 그대로 반환하기 때문에 `toString()` 메서드를 호출한다.
3. `toString()` 메서드의 결과값은 `'[Object object]'` 문자열이며 원시 타입이기 때문에 이 결과를 숫자로 변환한다. `'[Object object]'` 문자열은 숫자로 변환할 수 없는 값이기 때문에 최종적으로 NaN을 반환한다.

### 객체의 `valueOf()`와 `toString()`

만약 `valueOf()`와 `toString()` 메서드를 직접 정의한 경우 어떤 결과 값을 반환할까?

```javascript
const obj = {
  valueOf() {
    return 1;
  },
  toString() {
    return "toString";
  },
};

console.log(String(obj)); // 'toString'
console.log(Number(obj)); // 1
```

객체의 `valueOf()`와 `toString()` 메서드를 직접 정의하면 타입 변환의 결과도 달라진다. 따라서 `valueOf()`와 `toString()` 메서드를 재정의할 때는 주의해야 한다.

배열, Date, 정규식과 같은 특수한 객체들은 자체적인 `toString()` 또는 `valueOf()` 메서드를 가지고 있다. 예를 들어 배열을 문자열로 변경하면 배열의 원소를 콤마(,)로 구분하여 문자열로 병합한다.

```javascript
console.log([1]); // '1'
console.log([1, 2]); // '1,2'
```

> 객체의 원시 타입 변환 과정을 ECMAScript에서는 ToPrimitive 추상 연산으로 정의하고 있다.

## 암시적 강제 변환

암시적 강제 변환은 연산 중에 내부적으로 타입을 변환하는 것이다. 명시적 강제 변환과 달리 코드에서 명확하게 타입을 변환하는 것인지 알기 어렵다. 많은 개발자가 자바스크립트를 좋아하지 않는 이유 중 하나이며, 초보 개발자들이 가장 헷갈려 하는 부분이다. 하지만 암시적 강제 변환 역시 ECMAScript 명세의 기준대로 정확하게 동작하고 있다.

### 덧셈 연산자

덧셈 연산자는 숫자 연산이나 문자열을 병합할 때 사용하는 것이라고 생각할 수 있지만, 덧셈 연산자는 몇 가지 특징이 있다.

- 피연산자 중 하나가 문자열 타입인 경우 나머지 타입도 문자열로 변환하여 병합한다.

```javascript
// 문자열과 숫자의 덧셈 연산은 숫자를 문자로 변환하여 병합한다.
console.log(1 + ""); // '1'
```

> `String()`과 `a + ''`의 문자열 변환은 차이가 있다. 피연산자의 타입이 객체인 경우 `String()` 함수는 객체의 `toString()`, `valueOf()`의 순서로 메서드를 호출하여 결과를 반환하며, `a + ''`는 `valueOf()`, `toString()`의 순서로 호출한 결과를 반환한다.

- 피연산자 중 하나가 객체이며 문자열로 변환 가능한 경우 문자열로 변환하여 연산한다. 객체의 문자열 변환 과정은 '문자열로 변환'에서 설명한 과정과 동일하다.

```javascript
// 빈 객체는 '[object Object]' 문자열로 변환이 가능하므로 숫자 1을 문자열로 변환하여 두 문자열을 병합한다.
console.log(1 + {}); // '1[object Object]'
```

- 피연산자가 모두 문자열과 객체가 아닌 경우 숫자로 변환하여 연산한다. 만약 변환 결과의 타입이 각각 다른 경우 TypeError가 발생한다.

```javascript
// 피연산자 중 객체나 문자열이 없기 때문에 true를 숫자로 변환하여 연산한다.
console.log(1 + true); // 2
```

### 동등 연산자

동등 연산자의 가장 큰 특징은 암시적 강제 변환을 허용하는 것이다. 물론 피연산자의 타입이 서로 같은 경우에는 변환하지 않는다.

- 피연산자 중 하나는 문자열, 하나는 숫자인 경우 문자열을 숫자로 변환하여 동등함을 비교한다.

```javascript
// 문자열 '1'을 숫자로 변환하여 동등함을 판단한다.
console.log(1 == "1"); // true
```

- 피연산자 중 하나는 문자열, 다른 하나는 BigInt인 경우 문자열을 BigInt로 변환하여 동등함을 비교한다.

```javascript
// 문자열 '1'을 BigInt로 변환하여 동등함을 판단한다.
console.log(1n == "1"); // true
```

- 피연산자 중 하나는 null, 다른 하나는 undefined인 경우 동등하게 판단한다.

```javascript
console.log(null == undefined); // true
console.log(undefined == null); // true
```

- 피연산자 중 하나가 불리언일 경우 불리언을 숫자로 변환하여 동등함을 비교한다.

```javascript
// 불리언 true를 숫자로 변환하여 비교한다.
console.log(true == 1); // true
```

- 피연산자 중 하나는 객체, 다른 하나가 문자열, 숫자, BigInt, 심볼 중 하나일 경우 객체를 원시 타입으로 변환하여 동등함을 비교한다.

```javascript
// 빈 객체를 원시 타입으로 변환한 후 비교한다.
console.log("[object Object]" == {}); // true
```

- 피연산자 중 하나는 숫자, 다른 하나는 BigInt인 경우 내부적인 숫자 비교 알고리즘에 따라 비교한 결과를 반환한다.

```javascript
console.log(1 == 1n); // true
```

<br /><br />

true와 문자열 '1'은 전혀 다른 타입으로 동등 비교 시 false가 나올 것 같지만 그렇지 않다. 불리언 true는 숫자 1로 변환되어 문자열 '1'과 비교하게 되고, 이 과정에서 문자열 '1'은 숫자 1로 변환되어 최종적으로 숫자 1과 1을 비교하게 된다.

```javascript
console.log(true == "1"); // true
```

위에서 설명한 변환 규칙을 충실히 따른 결과이지만 확실히 가독성이 떨어진다. 이런 경우 명확하게 엄격한 동등 연산자를 사용하는 것이 가독성에 훨씬 좋다. 하지만 동등 연산자도 무조건 나쁜 것만은 아니다.

```javascript
function isEmpty(a) {
  if (a == null) {
    // ...
  }
}
```

특정 값의 비어 있음을 판단하기 위해 동등 연산자를 사용하였다. 동등 연산자는 null과 undefined를 동등하게 보기 때문에 두 경우의 수를 모두 편리하게 찾아낼 수 있다.

### 비교 연산자

비교 연산자는 숫자 데이터의 대소 비교에서 사용하는 경우가 대부분일 것이다. 하지만 비교 연산자 역시 동등 연산자처럼 피연산자가 서로 다른 타입일 경우 암시적 강제 변환이 발생한다. ECMAScript 명세는 a < b 연산 기준으로 설명하고 있기 때문에 이 기준을 따라 설명하도록 한다.<br />
비교 연산자는 크게 문자열 데이터의 비교, 그 이외의 경우 두 가지로 나누어져 있다. 다만, 피연산자가 객체인 경우 먼저 객체를 원시타입으로 변환한 후 비교한다. 변환된 결과가 모두 문자열이라면 문자열 비교를 하고 이외에는 문자열 외의 비교 규칙에 따라 비교한다.

#### 문자열 비교

문자열 비교는 각 문자를 알파벳 순서로 비교한다.

```javascript
console.log("a" < "b"); // true

// 왼쪽에서부터 문자 단위로 비교한다는 것에 주의하자! 왼쪽부터 '1'과 '0'을 먼저 비교하고, 그 다음 문자를 비교한다.
console.log("1" < "04"); // false
```

배열은 각각 'a', 'b' 문자열로 변환되기 때문에 문자열끼리의 비교를 수행한다.

```javascript
console.log(["a"] < ["b"]); // true
```

#### 문자열 외의 비교

문자열끼리의 비교가 아닌 그 외의 경우는 아래와 같은 규칙으로 동작한다.

- 피연산자 중 하나는 문자열, 다른 하나는 BigInt인 경우 문자열을 BigInt로 변환하여 비교한다.

```javascript
// 문자열 '1'을 BigInt로 변환하여 비교한다.
console.log("1" < 2n); // true
```

- 피연산자를 모두 숫자로 변환하여 비교한다. 만약 피연산자 중 하나는 숫자, 다른 하나는 BigInt인 경우 내부적인 숫자 비교 알고리즘에 의해 비교를 수행한다.

```javascript
// 불리언 true를 숫자로 변환한다.
console.log(1 < true); // false

// 숫자와 BigInt는 내부 숫자 비교 알고리즘에 의해 비교된다.
console.log(1n < 2); // true
```

#### 비교 연산과 타입 변환

비교 연산은 동등 연산과 달리 엄격한 비교 연산자 같은 표현식은 존재하지 않는다. 즉 **다른 타입 간의 비교 연산에서 암시적인 강제 변환을 막을 수 없다.** 하지만 동등 연산과 달리 비교 연산은 서로 다른 타입에 대해 사용할 일이 드믈고, 객체나 배열을 원시 타입과 비교하는 일도 거의 없다.

```javascript
// 아래와 같은 비교 연산 코드는 실제로 거의 사용하지 않는다.
const a = " 1";
const b = ["02"];

if (a < b) {
  // ...
}
```

만약 서로 다른 타입을 대상으로 비교 연산자를 사용한다면, 명시적 강제 변환을 통해 변환한 후 사용하는 것이 안전하다.

```javascript
const a = "1";
const b = ["02"];

if (Number(a) < Number(b)) {
  // ...
}
```

`Number()` 함수를 사용하여 모두 숫자로 변환한 후 비교한다. 이처럼 다른 타입의 비교 연산은 명시적 타입 변환을 통해 동일한 타입으로 변환한 후 실행하는 것이 안전하다.

#### 조건 표현식과 논리 연산자

조건 표현식에서 암시적 강제 변환은 아주 흔하게 사용된다. 모든 값은 불리언으로 변환되어 조건 표현식에서 평가된다. 빈 문자열, null, undefined 등 falsy한 값을 필터링하기 위해 많이 사용하며 명시적 강제 변환보다 더 많이 사용된다.

```javascript
const a = 0;
const b = "javascript";
const c = nul;

if (a) {
  console.log("호출되지 않음");
}

while (b) {
  console.log("truthy");
  break;
}

console.log(c ? "truthy" : "falsy"); // 'falsy'
```

조건 표현식에서의 암시적 강제 변환은 `Boolean()` 함수나 이중 부정 연산자를 사용하여 명시적 강제 변환을 수행하는 것보다 훨씬 간결하게 조건식을 표현할 수 있다.

- 논리 연산자(`&&`, `||`) : 자바스크립트의 논리 연산자는 단락 평가 방식을 따른다. 하지만 자바스크립트의 논리 연산자는 특이한 점이 있다. 논리 연산자의 결과값이 불리언 타입이 아닐 수 있다는 것이다.

  - `&&` 논리 연산자는 첫 번째 피연산자의 값이 true로 평가되는 경우 두 번째 피연산자의 값을 반환하고, false로 평가되면 첫 번째 피연산자의 값을 반환한다.
    1. `&&` 논리 연산자는 첫 번째 피연산자 a부터 평가한다.
    2. 첫 번째 피연산자 a는 불리언값이 아니므로 암시적 타입 변환을 통해 불리언값으로 변환된다. null은 falsy 값이기 때문에 false로 변환된다.
    3. a의 평가 결과가 false이기 때문에 단락 평가 방식에 따라 다음 피연산자인 b는 평가하지 않는다.
    4. 최종적으로 피연산자 a의 값을 반환한다.
  - `||` 논리 연산자는 첫 번째 피연산자의 값이 true로 평가되는 경우 첫 번째 피연산자의 값을 반환하고, false로 평가되면 두 번째 피연산자의 값을 반환한다.
    1. `||` 논리 연산자는 첫 번째 피연산자 b부터 평가한다.
    2. 첫 번째 피연산자 b는 불리언값이 아니므로 암시적 타입 변환을 통해 불리언 값으로 변환된다. 'javascript' 문자열은 truthy 값이기 때문에 true로 변환된다.
    3. b의 평가 결과가 true이기 때문에 단락 평가 방식에 따라 다음 피연산자인 c는 평가하지 않는다.
    4. 최종적으로 피연산자 b의 값을 반환한다.

  ```javascript
  const a = null;
  const b = "javascript";
  const c = 1;

  console.log(a && b); // null
  console.log(b || c); // 'javascript'
  ```
